#v19

# This script operates on the file ipaddresses.txt which is a list of target IPs to ssh into and update.
# It will also prune users who haven't logged in within 30 days, reducing the overall user account footprint and freeing up valuable storage.
# It will move from machine to machine updating, rebooting, and exiting.
# It will generate an error log at error_log.txt when it encounters any reasons it can't update.

#!/bin/bash

# update_all - Automated macOS Update Script for Multiple Machines
# This script SSHs into each machine, deploys the update script, and executes it

# File paths
IP_FILE="ipaddresses.txt"
CREDS_FILE="credentials.json"
UPDATE_OS_FILE="update_os"
ERROR_LOG="error_log.txt"
REMOTE_SCRIPT="prune_and_update"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to log errors
log_error() {
    local ip=$1
    local error=$2
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] IP: $ip - ERROR: $error" >> "$ERROR_LOG"
    echo -e "${RED}[ERROR]${NC} $ip - $error"
}

# Function to log success
log_success() {
    local ip=$1
    echo -e "${GREEN}[SUCCESS]${NC} $ip - Update completed successfully"
}

# Function to log info
log_info() {
    local ip=$1
    local msg=$2
    echo -e "${YELLOW}[INFO]${NC} $ip - $msg"
}

# Check if required files exist
if [[ ! -f "$IP_FILE" ]]; then
    echo -e "${RED}Error: $IP_FILE not found!${NC}"
    exit 1
fi

if [[ ! -f "$CREDS_FILE" ]]; then
    echo -e "${RED}Error: $CREDS_FILE not found!${NC}"
    exit 1
fi

if [[ ! -f "$UPDATE_OS_FILE" ]]; then
    echo -e "${RED}Error: $UPDATE_OS_FILE not found!${NC}"
    exit 1
fi

# Check if expect is installed (should be pre-installed on macOS)
if ! command -v expect &> /dev/null; then
    echo -e "${RED}Error: expect not found. This should be pre-installed on macOS.${NC}"
    exit 1
fi

# Parse credentials from JSON
USERNAME=$(grep -o '"username"[[:space:]]*:[[:space:]]*"[^"]*"' "$CREDS_FILE" | sed 's/.*"username"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
PASSWORD=$(grep -o '"password"[[:space:]]*:[[:space:]]*"[^"]*"' "$CREDS_FILE" | sed 's/.*"password"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

if [[ -z "$USERNAME" ]] || [[ -z "$PASSWORD" ]]; then
    echo -e "${RED}Error: Could not parse credentials from $CREDS_FILE${NC}"
    echo "Expected format: {\"username\": \"your_user\", \"password\": \"your_pass\"}"
    exit 1
fi

# Initialize error log
echo "=== Update Session Started: $(date) ===" >> "$ERROR_LOG"

# Read the update_os script content
UPDATE_SCRIPT_CONTENT=$(cat "$UPDATE_OS_FILE")

# Modify the script to remove interactive prompts for automated execution
AUTOMATED_SCRIPT=$(echo "$UPDATE_SCRIPT_CONTENT" | sed -e 's/read -p .* confirm/confirm="yes"/g' -e 's/read -p .* update_confirm/update_confirm="yes"/g')

echo ""
echo "=========================================="
echo "  Automated macOS Update Process"
echo "=========================================="
echo ""
echo "Starting update process for machines listed in $IP_FILE"
echo "Credentials: $USERNAME"
echo "Error log: $ERROR_LOG"
echo ""

# Counter for statistics
total=0
successful=0
failed=0

# Process each IP address
while IFS= read -r ip || [[ -n "$ip" ]]; do
    # Skip empty lines and comments
    [[ -z "$ip" ]] && continue
    [[ "$ip" =~ ^# ]] && continue
    
    total=$((total + 1))
    
    echo ""
    echo "=========================================="
    echo "Processing: $ip ($total)"
    echo "=========================================="
    
    # Test if host is reachable
    log_info "$ip" "Testing connection..."
    if ! ping -c 2 -W 3 "$ip" &>/dev/null; then
        log_error "$ip" "Host unreachable (ping failed)"
        failed=$((failed + 1))
        continue
    fi
    
    # Test SSH connection using expect
    log_info "$ip" "Attempting SSH connection..."
    ssh_test_status=0
    ssh_debug=$(expect -d -c "
        log_user 1
        set timeout 15
        spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $USERNAME@$ip echo 'Connection test'
        expect {
            \"Are you sure you want to continue connecting\" {
                send \"yes\r\"
                exp_continue
            }
            -re \"(P|p)assword:\" {
                send \"$PASSWORD\r\"
                expect {
                    \"Connection test\" { exit 0 }
                    \"Permission denied\" { exit 3 }
                    -re \"(P|p)assword:\" { exit 3 }
                    timeout { exit 1 }
                    eof { exit 1 }
                }
            }
            \"Connection refused\" { exit 4 }
            \"No route to host\" { exit 5 }
            timeout { exit 1 }
            eof { exit 1 }
        }
    " 2>&1) || ssh_test_status=$?
    
    if [[ $ssh_test_status -ne 0 ]]; then
        case $ssh_test_status in
            3) log_error "$ip" "SSH connection failed - Permission denied (wrong password?)" ;;
            4) log_error "$ip" "SSH connection failed - Connection refused (SSH service not running?)" ;;
            5) log_error "$ip" "SSH connection failed - No route to host" ;;
            *) log_error "$ip" "SSH connection failed - Timeout or unknown error (exit code: $ssh_test_status)" ;;
        esac
        echo "=== Debug output for $ip ===" >> "$ERROR_LOG"
        echo "$ssh_debug" >> "$ERROR_LOG"
        echo "=== End debug output ===" >> "$ERROR_LOG"
        echo ""
        failed=$((failed + 1))
        continue
    fi
    
    log_info "$ip" "Connected successfully"
    
    # Create the script on remote machine using expect
    log_info "$ip" "Deploying update script..."
    
    # First, create a temporary local file with the script content
    temp_script=$(mktemp)
    echo "$AUTOMATED_SCRIPT" > "$temp_script"
    
    deploy_status=0
    deploy_debug=$(expect -c "
        set timeout 30
        spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \"$temp_script\" $USERNAME@$ip:$REMOTE_SCRIPT
        expect {
            \"Are you sure you want to continue connecting\" {
                send \"yes\r\"
                exp_continue
            }
            -re \"(P|p)assword:\" {
                send \"$PASSWORD\r\"
                expect {
                    eof { exit 0 }
                    timeout { exit 1 }
                }
            }
            timeout { exit 1 }
        }
    " 2>&1) || deploy_status=$?
    
    # Clean up temp file
    rm -f "$temp_script"
    
    if [[ $deploy_status -ne 0 ]]; then
        log_error "$ip" "Failed to create remote script"
        echo "=== Deploy debug output for $ip ===" >> "$ERROR_LOG"
        echo "$deploy_debug" >> "$ERROR_LOG"
        echo "=== End deploy debug ===" >> "$ERROR_LOG"
        echo ""
        failed=$((failed + 1))
        continue
    fi
    
    # Make script executable using expect
    log_info "$ip" "Setting executable permissions..."
    chmod_status=0
    chmod_debug=$(expect -c "
        set timeout 30
        spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $USERNAME@$ip
        expect {
            \"Are you sure you want to continue connecting\" {
                send \"yes\r\"
                exp_continue
            }
            -re \"(P|p)assword:\" {
                send \"$PASSWORD\r\"
                expect -re \"\\\\$|#|%\" {
                    send \"echo '$PASSWORD' | sudo -S chmod +x $REMOTE_SCRIPT\r\"
                    expect {
                        \"incorrect password\" { exit 2 }
                        \"authentication failure\" { exit 2 }
                        \"Sorry, try again\" { exit 2 }
                        -re \"\\\\$|#|%\" { 
                            send \"exit\r\"
                            exit 0 
                        }
                        timeout { exit 0 }
                    }
                }
            }
            timeout { exit 1 }
        }
        expect eof
    " 2>&1) || chmod_status=$?
    
    if [[ $chmod_status -eq 2 ]]; then
        log_error "$ip" "Failed to authenticate for chmod"
        echo "=== Chmod debug output for $ip ===" >> "$ERROR_LOG"
        echo "$chmod_debug" >> "$ERROR_LOG"
        echo "=== End chmod debug ===" >> "$ERROR_LOG"
        echo ""
        failed=$((failed + 1))
        continue
    elif [[ $chmod_status -ne 0 ]]; then
        log_error "$ip" "Failed to set permissions (exit code: $chmod_status)"
        echo "=== Chmod debug output for $ip ===" >> "$ERROR_LOG"
        echo "$chmod_debug" >> "$ERROR_LOG"
        echo "=== End chmod debug ===" >> "$ERROR_LOG"
        echo ""
        failed=$((failed + 1))
        continue
    fi
    
    # Execute the update script using expect
    log_info "$ip" "Executing update script (this may take a while)..."
    echo ""
    echo "--- Live output from $ip ---"
    
    exec_status=0
    expect -c "
        set timeout -1
        log_user 1
        spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 $USERNAME@$ip
        expect {
            \"Are you sure you want to continue connecting\" {
                send \"yes\r\"
                exp_continue
            }
            -re \"(P|p)assword:\" {
                send \"$PASSWORD\r\"
                expect -re \"\\\\$|#|%\" {
                    send \"echo '$PASSWORD' | sudo -S bash ./$REMOTE_SCRIPT; echo '<<<SCRIPT_COMPLETE>>>'\r\"
                    expect {
                        \"<<<SCRIPT_COMPLETE>>>\" {
                            expect -re \"\\\\$|#|%\"
                            send \"exit\r\"
                            expect eof
                            exit 0
                        }
                        \"incorrect password\" { exit 2 }
                        \"authentication failure\" { exit 2 }
                        \"Failed to authenticate\" { exit 2 }
                    }
                }
            }
            timeout { exit 1 }
        }
    " || exec_status=$?
    
    echo ""
    echo "--- End output from $ip ---"
    echo ""
    
    # Check for authentication failure
    if [[ $exec_status -eq 2 ]]; then
        log_error "$ip" "Failed to authenticate during script execution"
        failed=$((failed + 1))
        continue
    fi
    
    # If we get here, assume success (machine may have rebooted)
    log_success "$ip"
    successful=$((successful + 1))
    
    # Brief pause before next machine
    sleep 3
    
done < "$IP_FILE"

# Final summary
echo ""
echo "=========================================="
echo "  Update Process Complete"
echo "=========================================="
echo ""
echo "Total machines: $total"
echo -e "${GREEN}Successful: $successful${NC}"
echo -e "${RED}Failed: $failed${NC}"
echo ""
echo "Check $ERROR_LOG for details on any failures."
echo ""
echo "=== Update Session Ended: $(date) ===" >> "$ERROR_LOG"
