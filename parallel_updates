# Parallel Updates for MacOS v3

# This script operates on the file ipaddresses.txt which is a list of target IPs to ssh into and update.
# It will also prune users who haven't logged in within 30 days, reducing the overall user account footprint and freeing up valuable storage.
# It will move from machine to machine updating, rebooting, and exiting.
# It functions in a parallel manner, meaning it SSH into multiple machines at once, definable at MAX_PARALLEL.
# This script will sleep 5 seconds between each parallel connection event.
# It gets its SSH credentials from credentials.json (which needs to be populated with the appropriate SSH credentials)
# It will generate an error log at error_log.txt when it encounters any reasons it can't update.

#!/bin/bash

# update_all - Automated macOS Update Script for Multiple Machines (PARALLEL VERSION)
# This script SSHs into multiple machines simultaneously and deploys updates

# Configuration
IP_FILE="ipaddresses.txt"
CREDS_FILE="credentials.json"
UPDATE_OS_FILE="update_os"
ERROR_LOG="error_log.txt"
REMOTE_SCRIPT="prune_and_update"
MAX_PARALLEL=5  # Maximum number of parallel updates
SLEEP=5 # sleep time between connection attempts.

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to log errors (simplified, no locking)
log_error() {
    local ip=$1
    local error=$2
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] IP: $ip - ERROR: $error" >> "$ERROR_LOG"
    echo -e "${RED}[ERROR]${NC} $ip - $error"
}

# Function to log success (simplified, no locking)
log_success() {
    local ip=$1
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] IP: $ip - SUCCESS: Update completed" >> "$ERROR_LOG"
    echo -e "${GREEN}[SUCCESS]${NC} $ip - Update completed successfully"
}

# Function to log info
log_info() {
    local ip=$1
    local msg=$2
    echo -e "${YELLOW}[INFO]${NC} $ip - $msg"
}

# Function to process a single machine
process_machine() {
    local ip=$1
    local username=$2
    local password=$3
    
    log_info "$ip" "Starting update process..."
    
    # Test if host is reachable
    if ! ping -c 2 -W 3 "$ip" &>/dev/null; then
        log_error "$ip" "Host unreachable (ping failed)"
        return 1
    fi
    
    # Test SSH connection
    ssh_test_status=0
    ssh_debug=$(expect -c "
        set timeout 15
        log_user 0
        spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $username@$ip echo 'Connection test'
        expect {
            \"Are you sure you want to continue connecting\" {
                send \"yes\r\"
                exp_continue
            }
            -re \"(P|p)assword:\" {
                send \"$password\r\"
                expect {
                    \"Connection test\" { exit 0 }
                    \"Permission denied\" { exit 3 }
                    -re \"(P|p)assword:\" { exit 3 }
                    timeout { exit 1 }
                    eof { exit 1 }
                }
            }
            \"Connection refused\" { exit 4 }
            \"No route to host\" { exit 5 }
            timeout { exit 1 }
            eof { exit 1 }
        }
    " 2>&1) || ssh_test_status=$?
    
    if [[ $ssh_test_status -ne 0 ]]; then
        case $ssh_test_status in
            3) log_error "$ip" "SSH connection failed - Permission denied" ;;
            4) log_error "$ip" "SSH connection failed - Connection refused" ;;
            5) log_error "$ip" "SSH connection failed - No route to host" ;;
            *) log_error "$ip" "SSH connection failed - Timeout or unknown error" ;;
        esac
        return 1
    fi
    
    log_info "$ip" "Connected successfully"
    
    # Create temporary local file with script content
    temp_script=$(mktemp)
    echo "$AUTOMATED_SCRIPT" > "$temp_script"
    
    # Deploy script using SCP
    log_info "$ip" "Deploying update script..."
    deploy_status=0
    expect -c "
        set timeout 30
        log_user 0
        spawn scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \"$temp_script\" $username@$ip:$REMOTE_SCRIPT
        expect {
            \"Are you sure you want to continue connecting\" {
                send \"yes\r\"
                exp_continue
            }
            -re \"(P|p)assword:\" {
                send \"$password\r\"
                expect {
                    eof { exit 0 }
                    timeout { exit 1 }
                }
            }
            timeout { exit 1 }
        }
    " >/dev/null 2>&1 || deploy_status=$?
    
    rm -f "$temp_script"
    
    if [[ $deploy_status -ne 0 ]]; then
        log_error "$ip" "Failed to create remote script"
        return 1
    fi
    
    # Make script executable
    log_info "$ip" "Setting executable permissions..."
    chmod_status=0
    expect -c "
        set timeout 30
        log_user 0
        spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $username@$ip
        expect {
            \"Are you sure you want to continue connecting\" {
                send \"yes\r\"
                exp_continue
            }
            -re \"(P|p)assword:\" {
                send \"$password\r\"
                expect -re \"\\\\$|#|%\" {
                    send \"echo '$password' | sudo -S chmod +x $REMOTE_SCRIPT\r\"
                    expect {
                        \"incorrect password\" { exit 2 }
                        \"authentication failure\" { exit 2 }
                        \"Sorry, try again\" { exit 2 }
                        -re \"\\\\$|#|%\" { 
                            send \"exit\r\"
                            exit 0 
                        }
                        timeout { exit 0 }
                    }
                }
            }
            timeout { exit 1 }
        }
        expect eof
    " >/dev/null 2>&1 || chmod_status=$?
    
    if [[ $chmod_status -eq 2 ]]; then
        log_error "$ip" "Failed to authenticate for chmod"
        return 1
    elif [[ $chmod_status -ne 0 ]]; then
        log_error "$ip" "Failed to set permissions"
        return 1
    fi
    
    # Execute the update script
    log_info "$ip" "Executing update script (this may take a while)..."
    echo -e "${BLUE}--- Live output from $ip ---${NC}"
    
    exec_status=0
    expect -c "
        set timeout -1
        log_user 0
        spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 $username@$ip
        expect {
            \"Are you sure you want to continue connecting\" {
                send \"yes\r\"
                exp_continue
            }
            -re \"(P|p)assword:\" {
                send \"$password\r\"
                expect -re \"\\\\$|#|%\" {
                    log_user 1
                    send \"echo '$password' | sudo -S bash ./$REMOTE_SCRIPT; echo '<<<SCRIPT_COMPLETE>>>'\r\"
                    expect {
                        \"<<<SCRIPT_COMPLETE>>>\" {
                            log_user 0
                            expect -re \"\\\\$|#|%\"
                            send \"exit\r\"
                            expect eof
                            exit 0
                        }
                        \"incorrect password\" { exit 2 }
                        \"authentication failure\" { exit 2 }
                        \"Failed to authenticate\" { exit 2 }
                    }
                }
            }
            timeout { exit 1 }
        }
    " || exec_status=$?
    
    echo -e "${BLUE}--- End output from $ip ---${NC}"
    
    if [[ $exec_status -eq 2 ]]; then
        log_error "$ip" "Failed to authenticate during script execution"
        return 1
    fi
    
    log_success "$ip"
    return 0
}

# Export functions and variables for subshells
export -f process_machine log_error log_success log_info
export RED GREEN YELLOW BLUE NC ERROR_LOG REMOTE_SCRIPT AUTOMATED_SCRIPT

# Check if required files exist
if [[ ! -f "$IP_FILE" ]]; then
    echo -e "${RED}Error: $IP_FILE not found!${NC}"
    exit 1
fi

if [[ ! -f "$CREDS_FILE" ]]; then
    echo -e "${RED}Error: $CREDS_FILE not found!${NC}"
    exit 1
fi

if [[ ! -f "$UPDATE_OS_FILE" ]]; then
    echo -e "${RED}Error: $UPDATE_OS_FILE not found!${NC}"
    exit 1
fi

# Check if expect is installed
if ! command -v expect &> /dev/null; then
    echo -e "${RED}Error: expect not found. This should be pre-installed on macOS.${NC}"
    exit 1
fi

# Parse credentials from JSON
USERNAME=$(grep -o '"username"[[:space:]]*:[[:space:]]*"[^"]*"' "$CREDS_FILE" | sed 's/.*"username"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
PASSWORD=$(grep -o '"password"[[:space:]]*:[[:space:]]*"[^"]*"' "$CREDS_FILE" | sed 's/.*"password"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

if [[ -z "$USERNAME" ]] || [[ -z "$PASSWORD" ]]; then
    echo -e "${RED}Error: Could not parse credentials from $CREDS_FILE${NC}"
    echo "Expected format: {\"username\": \"your_user\", \"password\": \"your_pass\"}"
    exit 1
fi

# Read and prepare the update script
UPDATE_SCRIPT_CONTENT=$(cat "$UPDATE_OS_FILE")
AUTOMATED_SCRIPT=$(echo "$UPDATE_SCRIPT_CONTENT" | sed -e 's/read -p .* confirm/confirm="yes"/g' -e 's/read -p .* update_confirm/update_confirm="yes"/g')

# Initialize error log
echo "=== Parallel Update Session Started: $(date) ===" >> "$ERROR_LOG"
echo "Maximum parallel updates: $MAX_PARALLEL" >> "$ERROR_LOG"

echo ""
echo "=========================================="
echo "  Automated macOS Update Process"
echo "  (PARALLEL MODE - Max: $MAX_PARALLEL)"
echo "=========================================="
echo ""
echo "Credentials: $USERNAME"
echo "Error log: $ERROR_LOG"
echo ""

# Read all IPs into an array (Bash 3.2 compatible way)
ip_array=()
while IFS= read -r line; do
    # Skip comments and empty lines
    [[ "$line" =~ ^#.*$ ]] && continue
    [[ -z "$line" || "$line" =~ ^[[:space:]]*$ ]] && continue
    ip_array+=("$line")
done < "$IP_FILE"

total=${#ip_array[@]}

echo "Total machines to process: $total"
echo ""

# Counters
successful=0
failed=0
current_index=0

# Use a temporary directory to track running jobs (instead of associative array)
JOB_DIR=$(mktemp -d)
trap "rm -rf $JOB_DIR" EXIT

# Function to start a job
start_job() {
    local ip=$1
    log_info "$ip" "Launching parallel update job..."
    process_machine "$ip" "$USERNAME" "$PASSWORD" &
    local pid=$!
    echo "$ip" > "$JOB_DIR/$pid"
    sleep $SLEEP  # 5-second stagger between launches
}

# Function to wait for any job to complete
wait_for_job() {
    while true; do
        for pid_file in "$JOB_DIR"/*; do
            [[ ! -f "$pid_file" ]] && continue
            
            local pid=$(basename "$pid_file")
            if ! kill -0 "$pid" 2>/dev/null; then
                # Job finished
                wait "$pid"
                local exit_code=$?
                local ip=$(cat "$pid_file")
                
                if [[ $exit_code -eq 0 ]]; then
                    ((successful++))
                else
                    ((failed++))
                fi
                
                rm -f "$pid_file"
                return 0
            fi
        done
        sleep 1
    done
}

# Function to count running jobs
count_running_jobs() {
    local count=0
    for pid_file in "$JOB_DIR"/*; do
        [[ -f "$pid_file" ]] && ((count++))
    done
    echo $count
}

# Main parallel processing loop
while [[ $current_index -lt $total ]] || [[ $(count_running_jobs) -gt 0 ]]; do
    # Start new jobs up to MAX_PARALLEL
    while [[ $(count_running_jobs) -lt $MAX_PARALLEL ]] && [[ $current_index -lt $total ]]; do
        ip=${ip_array[$current_index]}
        start_job "$ip"
        ((current_index++))
    done
    
    # Wait for at least one job to complete if we're at max capacity
    if [[ $(count_running_jobs) -ge $MAX_PARALLEL ]] || [[ $current_index -ge $total ]]; then
        wait_for_job
    fi
done

# Final summary
echo ""
echo "=========================================="
echo "  Update Process Complete"
echo "=========================================="
echo ""
echo "Total machines: $total"
echo -e "${GREEN}Successful: $successful${NC}"
echo -e "${RED}Failed: $failed${NC}"
echo ""
echo "Check $ERROR_LOG for details on any failures."
echo ""
echo "=== Parallel Update Session Ended: $(date) ===" >> "$ERROR_LOG"
